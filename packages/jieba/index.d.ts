/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Jieba {
  /** Create a new instance with empty dict */
  constructor()
  /**
   * Create a new instance with dict
   *
   * With the default dict, you can use `dict` from `@node-rs/jieba/dict`:
   * ```js
   * import { Jieba } from '@node-rs/jieba'
   * import { dict } from '@node-rs/jieba/dict'
   *
   * const jieba = Jieba.withDict(dict)
   * ```
   */
  static withDict(dict: Uint8Array): Jieba
  /** Load dictionary after initialization */
  loadDict(dict: Uint8Array): void
  /**
   * Cut the input text
   *
   * ## Params
   *
   * `sentence`: input text
   *
   * `hmm`: enable HMM or not
   */
  cut(sentence: string | Uint8Array, hmm?: boolean | undefined | null): string[]
  /** Cut the input text asynchronously */
  cutAsync(sentence: string | Uint8Array, hmm?: boolean | undefined | null, signal?: AbortSignal | undefined | null): Promise<unknown>
  /**
   * Cut the input text, return all possible words
   *
   * ## Params
   *
   * `sentence`: input text
   */
  cutAll(sentence: string | Uint8Array): string[]
  /**
   * Cut the input text in search mode
   *
   * ## Params
   *
   * `sentence`: input text
   *
   * `hmm`: enable HMM or not
   */
  cutForSearch(sentence: string | Uint8Array, hmm?: boolean | undefined | null): string[]
  /**
   * Tag the input text
   *
   * ## Params
   *
   * `sentence`: input text
   *
   * `hmm`: enable HMM or not
   */
  tag(sentence: string | Uint8Array, hmm?: boolean | undefined | null): Array<TaggedWord>
}

export declare class TfIdf {
  static withDict(dict: Uint8Array): TfIdf
  /** Creates an TfIdf. */
  constructor()
  /**
   * Merges entires from `dict` into the `idf_dict`.
   * ```js
   * import { Jieba, TfIdf } from '@node-rs/jieba';
   *
   * import { dict, idf } from '@node-rs/jieba/dict';
   *
   * // Create default Jieba instance
   * const jieba = Jieba.withDict(dict);
   *
   * // Create TfIdf instance and load initial dictionary
   * let initIdf = "生化学 13.900677652
  ";
   * const tfidf = new TfIdf();
   * tfidf.loadDict(Buffer.from(initIdf));
   *
   * // Extract keywords with initial dictionary
   * const text = "生化学不是光化学的,";
   * const topK = jieba.extract(text, 3);
   * // Result would be like:
   * // [
   * //   { keyword: '不是', weight: 4.6335592173333335 },
   * //   { keyword: '光化学', weight: 4.6335592173333335 },
   * //   { keyword: '生化学', weight: 4.6335592173333335 }
   * // ]
   *
   * // Load new dictionary with different weights
   * let newIdf = "光化学 99.123456789
  ";
   * tfidf.loadDict(Buffer.from(newIdf));
   *
   * // Extract keywords again with updated dictionary
   * const newTopK = jieba.extract(text, 3);
   * // Result would be like:
   * // [
   * //   { keyword: '不是', weight: 33.041152263 },
   * //   { keyword: '光化学', weight: 33.041152263 },
   * //   { keyword: '生化学', weight: 4.6335592173333335 }
   * // ]
   * ```
   */
  loadDict(dict: Uint8Array): void
  setConfig(config: KeywordExtractConfig): void
  /**
   * Uses TF-IDF algorithm to extract the `top_k` keywords from `sentence`.
   *
   * If `allowed_pos` is not empty, then only terms matching those parts if
   * speech are considered.
   */
  extractKeywords(jieba: Jieba, sentence: string, topK: number, allowedPos?: Array<string> | undefined | null): Array<Keyword>
}

export interface Keyword {
  keyword: string
  weight: number
}

/**
 * Creates a KeywordExtractConfig state that contains filter criteria as
 * well as segmentation configuration for use by keyword extraction
 * implementations.
 */
export interface KeywordExtractConfig {
  stopWords?: Set<string> | undefined
  /** Any segments less than this length will not be considered a Keyword */
  minKeywordLength?: number
  /** If true, fall back to hmm model if segment cannot be found in the dictionary */
  useHmm?: boolean
}

export interface TaggedWord {
  tag: string
  word: string
}
